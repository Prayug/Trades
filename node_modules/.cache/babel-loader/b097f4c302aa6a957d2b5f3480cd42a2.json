{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n      end = boundaries.end;\n  var index = 0; // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n\n  var stepsize = 1;\n  var start = initialStart;\n\n  var _loop = function _loop() {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index]; // Break condition - If we have evaluate all the ticks, then we are done.\n\n    if (entry === undefined) {\n      return {\n        v: getEveryNthWithCondition(ticks, stepsize)\n      };\n    } // Check if the element collides with the next element\n\n\n    var i = index;\n    var size;\n\n    var getSize = function getSize() {\n      if (size === undefined) {\n        size = getTickSize(entry, i);\n      }\n\n      return size;\n    };\n\n    var tickCoord = entry.coordinate; // We will always show the first tick.\n\n    var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (getSize() / 2 + minTickGap);\n      index += stepsize;\n    }\n  },\n      _ret;\n\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n\n  return [];\n}","map":{"version":3,"sources":["/Users/prayugsigdel/Coding/Trades/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"names":["isVisible","getEveryNthWithCondition","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","initialStart","start","end","index","stepsize","_loop","entry","undefined","v","i","size","getSize","tickCoord","coordinate","isShow","_ret","length"],"mappings":"AAAA,SAASA,SAAT,QAA0B,mBAA1B;AACA,SAASC,wBAAT,QAAyC,kCAAzC;AACA,OAAO,SAASC,mBAAT,CAA6BC,IAA7B,EAAmCC,UAAnC,EAA+CC,WAA/C,EAA4DC,KAA5D,EAAmEC,UAAnE,EAA+E;AACpF,MAAIC,MAAM,GAAG,CAACF,KAAK,IAAI,EAAV,EAAcG,KAAd,EAAb;AACA,MAAIC,YAAY,GAAGN,UAAU,CAACO,KAA9B;AAAA,MACEC,GAAG,GAAGR,UAAU,CAACQ,GADnB;AAEA,MAAIC,KAAK,GAAG,CAAZ,CAJoF,CAKpF;AACA;;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIH,KAAK,GAAGD,YAAZ;;AACA,MAAIK,KAAK,GAAG,SAASA,KAAT,GAAiB;AACzB;AACA;AAEA,QAAIC,KAAK,GAAGV,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACO,KAAD,CAA/D,CAJyB,CAMzB;;AACA,QAAIG,KAAK,KAAKC,SAAd,EAAyB;AACvB,aAAO;AACLC,QAAAA,CAAC,EAAEjB,wBAAwB,CAACK,KAAD,EAAQQ,QAAR;AADtB,OAAP;AAGD,KAXwB,CAazB;;;AACA,QAAIK,CAAC,GAAGN,KAAR;AACA,QAAIO,IAAJ;;AACA,QAAIC,OAAO,GAAG,SAASA,OAAT,GAAmB;AAC/B,UAAID,IAAI,KAAKH,SAAb,EAAwB;AACtBG,QAAAA,IAAI,GAAGf,WAAW,CAACW,KAAD,EAAQG,CAAR,CAAlB;AACD;;AACD,aAAOC,IAAP;AACD,KALD;;AAMA,QAAIE,SAAS,GAAGN,KAAK,CAACO,UAAtB,CAtByB,CAuBzB;;AACA,QAAIC,MAAM,GAAGX,KAAK,KAAK,CAAV,IAAeb,SAAS,CAACG,IAAD,EAAOmB,SAAP,EAAkBD,OAAlB,EAA2BV,KAA3B,EAAkCC,GAAlC,CAArC;;AACA,QAAI,CAACY,MAAL,EAAa;AACX;AACAX,MAAAA,KAAK,GAAG,CAAR;AACAF,MAAAA,KAAK,GAAGD,YAAR;AACAI,MAAAA,QAAQ,IAAI,CAAZ;AACD;;AACD,QAAIU,MAAJ,EAAY;AACV;AACAb,MAAAA,KAAK,GAAGW,SAAS,GAAGnB,IAAI,IAAIkB,OAAO,KAAK,CAAZ,GAAgBd,UAApB,CAAxB;AACAM,MAAAA,KAAK,IAAIC,QAAT;AACD;AACF,GApCH;AAAA,MAqCEW,IArCF;;AAsCA,SAAOX,QAAQ,IAAIN,MAAM,CAACkB,MAA1B,EAAkC;AAChCD,IAAAA,IAAI,GAAGV,KAAK,EAAZ;AACA,QAAIU,IAAJ,EAAU,OAAOA,IAAI,CAACP,CAAZ;AACX;;AACD,SAAO,EAAP;AACD","sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n    end = boundaries.end;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  var _loop = function _loop() {\n      // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n      // If it can not, then increase the stepsize by 1, and try again.\n\n      var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n      // Break condition - If we have evaluate all the ticks, then we are done.\n      if (entry === undefined) {\n        return {\n          v: getEveryNthWithCondition(ticks, stepsize)\n        };\n      }\n\n      // Check if the element collides with the next element\n      var i = index;\n      var size;\n      var getSize = function getSize() {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n        return size;\n      };\n      var tickCoord = entry.coordinate;\n      // We will always show the first tick.\n      var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n      if (!isShow) {\n        // Start all over with a larger stepsize\n        index = 0;\n        start = initialStart;\n        stepsize += 1;\n      }\n      if (isShow) {\n        // If it can be shown, update the start\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        index += stepsize;\n      }\n    },\n    _ret;\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}"]},"metadata":{},"sourceType":"module"}