{"ast":null,"code":"import max from \"./max.js\";\nimport maxIndex from \"./maxIndex.js\";\nimport min from \"./min.js\";\nimport minIndex from \"./minIndex.js\";\nimport quickselect from \"./quickselect.js\";\nimport number, { numbers } from \"./number.js\";\nimport { ascendingDefined } from \"./sort.js\";\nimport greatest from \"./greatest.js\";\nexport default function quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\nexport function quantileSorted(values, p) {\n  let valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : number;\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\nexport function quantileIndex(values, p) {\n  let valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : number;\n  if (isNaN(p = +p)) return;\n  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));\n  if (p <= 0) return minIndex(numbers);\n  if (p >= 1) return maxIndex(numbers);\n  var numbers,\n      index = Uint32Array.from(values, (_, i) => i),\n      j = numbers.length - 1,\n      i = Math.floor(j * p);\n  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));\n  i = greatest(index.subarray(0, i + 1), i => numbers[i]);\n  return i >= 0 ? i : -1;\n}","map":{"version":3,"sources":["/Users/prayugsigdel/Coding/Trades/node_modules/d3-array/src/quantile.js"],"names":["max","maxIndex","min","minIndex","quickselect","number","numbers","ascendingDefined","greatest","quantile","values","p","valueof","Float64Array","from","n","length","isNaN","i","i0","Math","floor","value0","subarray","value1","quantileSorted","quantileIndex","_","index","Uint32Array","j"],"mappings":"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","sourcesContent":["import max from \"./max.js\";\nimport maxIndex from \"./maxIndex.js\";\nimport min from \"./min.js\";\nimport minIndex from \"./minIndex.js\";\nimport quickselect from \"./quickselect.js\";\nimport number, {numbers} from \"./number.js\";\nimport {ascendingDefined} from \"./sort.js\";\nimport greatest from \"./greatest.js\";\n\nexport default function quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileSorted(values, p, valueof = number) {\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileIndex(values, p, valueof = number) {\n  if (isNaN(p = +p)) return;\n  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));\n  if (p <= 0) return minIndex(numbers);\n  if (p >= 1) return maxIndex(numbers);\n  var numbers,\n      index = Uint32Array.from(values, (_, i) => i),\n      j = numbers.length - 1,\n      i = Math.floor(j * p);\n  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));\n  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);\n  return i >= 0 ? i : -1;\n}\n"]},"metadata":{},"sourceType":"module"}