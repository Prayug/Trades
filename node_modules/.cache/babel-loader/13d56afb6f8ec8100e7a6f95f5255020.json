{"ast":null,"code":"var getOwnPropertyNames = Object.getOwnPropertyNames,\n    getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */\n\nfunction combineComparators(comparatorA, comparatorB) {\n  return function isEqual(a, b, state) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\n\n\nfunction createIsCircular(areItemsEqual) {\n  return function isCircular(a, b, state) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    var cache = state.cache;\n    var cachedA = cache.get(a);\n    var cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n    var result = areItemsEqual(a, b, state);\n    cache.delete(a);\n    cache.delete(b);\n    return result;\n  };\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\n\n\nfunction getStrictProperties(object) {\n  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */\n\n\nvar hasOwn = Object.hasOwn || function (object, property) {\n  return hasOwnProperty.call(object, property);\n};\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\n\n\nfunction sameValueZeroEqual(a, b) {\n  return a || b ? a === b : a === b || a !== a && b !== b;\n}\n\nvar OWNER = '_owner';\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */\n\nfunction areArraysEqual(a, b, state) {\n  var index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */\n\n\nfunction areDatesEqual(a, b) {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the `Map`s are equal in value.\n */\n\n\nfunction areMapsEqual(a, b, state) {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  var matchedIndices = {};\n  var aIterable = a.entries();\n  var index = 0;\n  var aResult;\n  var bResult;\n\n  while (aResult = aIterable.next()) {\n    if (aResult.done) {\n      break;\n    }\n\n    var bIterable = b.entries();\n    var hasMatch = false;\n    var matchIndex = 0;\n\n    while (bResult = bIterable.next()) {\n      if (bResult.done) {\n        break;\n      }\n\n      var _a = aResult.value,\n          aKey = _a[0],\n          aValue = _a[1];\n      var _b = bResult.value,\n          bKey = _b[0],\n          bValue = _b[1];\n\n      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index, matchIndex, a, b, state) && state.equals(aValue, bValue, aKey, bKey, a, b, state))) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n/**\n * Whether the objects are equal in value.\n */\n\n\nfunction areObjectsEqual(a, b, state) {\n  var properties = keys(a);\n  var index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  var property; // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n\n  while (index-- > 0) {\n    property = properties[index];\n\n    if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n      return false;\n    }\n\n    if (!hasOwn(b, property) || !state.equals(a[property], b[property], property, property, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */\n\n\nfunction areObjectsEqualStrict(a, b, state) {\n  var properties = getStrictProperties(a);\n  var index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  var property;\n  var descriptorA;\n  var descriptorB; // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n\n  while (index-- > 0) {\n    property = properties[index];\n\n    if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n      return false;\n    }\n\n    if (!hasOwn(b, property)) {\n      return false;\n    }\n\n    if (!state.equals(a[property], b[property], property, property, a, b, state)) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\n\n\nfunction arePrimitiveWrappersEqual(a, b) {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */\n\n\nfunction areRegExpsEqual(a, b) {\n  return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */\n\n\nfunction areSetsEqual(a, b, state) {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  var matchedIndices = {};\n  var aIterable = a.values();\n  var aResult;\n  var bResult;\n\n  while (aResult = aIterable.next()) {\n    if (aResult.done) {\n      break;\n    }\n\n    var bIterable = b.values();\n    var hasMatch = false;\n    var matchIndex = 0;\n\n    while (bResult = bIterable.next()) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */\n\n\nfunction areTypedArraysEqual(a, b) {\n  var index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\nvar BOOLEAN_TAG = '[object Boolean]';\nvar DATE_TAG = '[object Date]';\nvar MAP_TAG = '[object Map]';\nvar NUMBER_TAG = '[object Number]';\nvar OBJECT_TAG = '[object Object]';\nvar REG_EXP_TAG = '[object RegExp]';\nvar SET_TAG = '[object Set]';\nvar STRING_TAG = '[object String]';\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView ? ArrayBuffer.isView : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\n\nfunction createEqualityComparator(_a) {\n  var areArraysEqual = _a.areArraysEqual,\n      areDatesEqual = _a.areDatesEqual,\n      areMapsEqual = _a.areMapsEqual,\n      areObjectsEqual = _a.areObjectsEqual,\n      arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual,\n      areRegExpsEqual = _a.areRegExpsEqual,\n      areSetsEqual = _a.areSetsEqual,\n      areTypedArraysEqual = _a.areTypedArraysEqual;\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n\n  return function comparator(a, b, state) {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    } // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n\n\n    if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {\n      return a !== a && b !== b;\n    }\n\n    var constructor = a.constructor; // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n\n    if (constructor !== b.constructor) {\n      return false;\n    } // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n\n\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    } // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n\n\n    if (isArray(a)) {\n      return areArraysEqual(a, b, state);\n    } // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n    // capturing the string tag or comparing against all possible constructors.\n\n\n    if (isTypedArray != null && isTypedArray(a)) {\n      return areTypedArraysEqual(a, b, state);\n    } // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    } // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n\n\n    var tag = getTag(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n    } // If an arguments tag, it should be treated as a standard object.\n\n\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    } // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n\n\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    } // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n\n\n    return false;\n  };\n}\n/**\n * Create the configuration object used for building comparators.\n */\n\n\nfunction createEqualityComparatorConfig(_a) {\n  var circular = _a.circular,\n      createCustomConfig = _a.createCustomConfig,\n      strict = _a.strict;\n  var config = {\n    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n    areDatesEqual: areDatesEqual,\n    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n    areRegExpsEqual: areRegExpsEqual,\n    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual\n  };\n\n  if (createCustomConfig) {\n    config = assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n    config = assign({}, config, {\n      areArraysEqual: areArraysEqual$1,\n      areMapsEqual: areMapsEqual$1,\n      areObjectsEqual: areObjectsEqual$1,\n      areSetsEqual: areSetsEqual$1\n    });\n  }\n\n  return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\n\n\nfunction createInternalEqualityComparator(compare) {\n  return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n    return compare(a, b, state);\n  };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */\n\n\nfunction createIsEqual(_a) {\n  var circular = _a.circular,\n      comparator = _a.comparator,\n      createState = _a.createState,\n      equals = _a.equals,\n      strict = _a.strict;\n\n  if (createState) {\n    return function isEqual(a, b) {\n      var _a = createState(),\n          _b = _a.cache,\n          cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b,\n          meta = _a.meta;\n\n      return comparator(a, b, {\n        cache: cache,\n        equals: equals,\n        meta: meta,\n        strict: strict\n      });\n    };\n  }\n\n  if (circular) {\n    return function isEqual(a, b) {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals: equals,\n        meta: undefined,\n        strict: strict\n      });\n    };\n  }\n\n  var state = {\n    cache: undefined,\n    equals: equals,\n    meta: undefined,\n    strict: strict\n  };\n  return function isEqual(a, b) {\n    return comparator(a, b, state);\n  };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */\n\n\nvar deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\n\nvar strictDeepEqual = createCustomEqual({\n  strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\n\nvar circularDeepEqual = createCustomEqual({\n  circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\n\nvar strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */\n\nvar shallowEqual = createCustomEqual({\n  createInternalComparator: function () {\n    return sameValueZeroEqual;\n  }\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\n\nvar strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: function () {\n    return sameValueZeroEqual;\n  }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\n\nvar circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: function () {\n    return sameValueZeroEqual;\n  }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\n\nvar strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: function () {\n    return sameValueZeroEqual;\n  },\n  strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\n\nfunction createCustomEqual(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.circular,\n      circular = _a === void 0 ? false : _a,\n      createCustomInternalComparator = options.createInternalComparator,\n      createState = options.createState,\n      _b = options.strict,\n      strict = _b === void 0 ? false : _b;\n  var config = createEqualityComparatorConfig(options);\n  var comparator = createEqualityComparator(config);\n  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n  return createIsEqual({\n    circular: circular,\n    comparator: comparator,\n    createState: createState,\n    equals: equals,\n    strict: strict\n  });\n}\n\nexport { circularDeepEqual, circularShallowEqual, createCustomEqual, deepEqual, sameValueZeroEqual, shallowEqual, strictCircularDeepEqual, strictCircularShallowEqual, strictDeepEqual, strictShallowEqual };","map":{"version":3,"sources":["/Users/prayugsigdel/Coding/Trades/node_modules/fast-equals/src/utils.ts","/Users/prayugsigdel/Coding/Trades/node_modules/fast-equals/src/equals.ts","/Users/prayugsigdel/Coding/Trades/node_modules/fast-equals/src/comparator.ts","/Users/prayugsigdel/Coding/Trades/node_modules/fast-equals/src/index.ts"],"names":["areObjectsEqualStrictDefault","areArraysEqualDefault","areDatesEqualDefault","areMapsEqualDefault","areObjectsEqualDefault","arePrimitiveWrappersEqualDefault","areRegExpsEqualDefault","areSetsEqualDefault","areArraysEqual","areMapsEqual","areObjectsEqual","areSetsEqual"],"mappings":"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","sourcesContent":["import {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  Dictionary,\n  State,\n  TypeEqualityComparator,\n} from './internalTypes';\n\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Combine two comparators into a single comparators.\n */\nexport function combineComparators<Meta>(\n  comparatorA: AnyEqualityComparator<Meta>,\n  comparatorB: AnyEqualityComparator<Meta>,\n) {\n  return function isEqual<A, B>(a: A, b: B, state: State<Meta>) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<\n  AreItemsEqual extends TypeEqualityComparator<any, any>,\n>(areItemsEqual: AreItemsEqual): AreItemsEqual {\n  return function isCircular(\n    a: any,\n    b: any,\n    state: CircularState<Cache<any, any>>,\n  ) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    const { cache } = state;\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, state);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nexport function getStrictProperties(\n  object: Dictionary,\n): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object),\n  );\n}\n\n/**\n * Whether the object contains the property passed as an own property.\n */\nexport const hasOwn =\n  Object.hasOwn ||\n  ((object: Dictionary, property: number | string | symbol) =>\n    hasOwnProperty.call(object, property));\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a || b ? a === b : a === b || (a !== a && b !== b);\n}\n","import { getStrictProperties, hasOwn, sameValueZeroEqual } from './utils';\nimport type {\n  Dictionary,\n  PrimitiveWrapper,\n  State,\n  TypedArray,\n} from './internalTypes';\n\nconst OWNER = '_owner';\n\nconst { getOwnPropertyDescriptor, keys } = Object;\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(a: any[], b: any[], state: State<any>) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the dates passed are equal in value.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.entries();\n\n  let index = 0;\n  let aResult: IteratorResult<[any, any]>;\n  let bResult: IteratorResult<[any, any]>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.entries();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      const [aKey, aValue] = aResult.value;\n      const [bKey, bValue] = bResult.value;\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch =\n          state.equals(aKey, bKey, index, matchIndex, a, b, state) &&\n          state.equals(aValue, bValue, aKey, bKey, a, b, state))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = keys(a);\n\n  let index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  let property: string;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (\n      !hasOwn(b, property) ||\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nexport function areObjectsEqualStrict(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = getStrictProperties(a);\n\n  let index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  let property: string | symbol;\n  let descriptorA: ReturnType<typeof getOwnPropertyDescriptor>;\n  let descriptorB: ReturnType<typeof getOwnPropertyDescriptor>;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (!hasOwn(b, property)) {\n      return false;\n    }\n\n    if (\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if (\n      (descriptorA || descriptorB) &&\n      (!descriptorA ||\n        !descriptorB ||\n        descriptorA.configurable !== descriptorB.configurable ||\n        descriptorA.enumerable !== descriptorB.enumerable ||\n        descriptorA.writable !== descriptorB.writable)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nexport function arePrimitiveWrappersEqual(\n  a: PrimitiveWrapper,\n  b: PrimitiveWrapper,\n): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n\n/**\n * Whether the regexps passed are equal in value.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.values();\n\n  let aResult: IteratorResult<any>;\n  let bResult: IteratorResult<any>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.values();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch = state.equals(\n          aResult.value,\n          bResult.value,\n          aResult.value,\n          bResult.value,\n          a,\n          b,\n          state,\n        ))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the TypedArray instances are equal in value.\n */\nexport function areTypedArraysEqual(a: TypedArray, b: TypedArray) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  areArraysEqual as areArraysEqualDefault,\n  areDatesEqual as areDatesEqualDefault,\n  areMapsEqual as areMapsEqualDefault,\n  areObjectsEqual as areObjectsEqualDefault,\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\n  areRegExpsEqual as areRegExpsEqualDefault,\n  areSetsEqual as areSetsEqualDefault,\n  areTypedArraysEqual,\n} from './equals';\nimport { combineComparators, createIsCircular } from './utils';\nimport type {\n  ComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  EqualityComparator,\n  InternalEqualityComparator,\n  State,\n} from './internalTypes';\n\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATE_TAG = '[object Date]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\n\nconst { isArray } = Array;\nconst isTypedArray =\n  typeof ArrayBuffer === 'function' && ArrayBuffer.isView\n    ? ArrayBuffer.isView\n    : null;\nconst { assign } = Object;\nconst getTag = Object.prototype.toString.call.bind(\n  Object.prototype.toString,\n) as (a: object) => string;\n\ninterface CreateIsEqualOptions<Meta> {\n  circular: boolean;\n  comparator: EqualityComparator<Meta>;\n  createState: CreateState<Meta> | undefined;\n  equals: InternalEqualityComparator<Meta>;\n  strict: boolean;\n}\n\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nexport function createEqualityComparator<Meta>({\n  areArraysEqual,\n  areDatesEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  arePrimitiveWrappersEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  areTypedArraysEqual,\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n    if (\n      a == null ||\n      b == null ||\n      typeof a !== 'object' ||\n      typeof b !== 'object'\n    ) {\n      return a !== a && b !== b;\n    }\n\n    const constructor = a.constructor;\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n\n    // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n    // capturing the string tag or comparing against all possible constructors.\n    if (isTypedArray != null && isTypedArray(a)) {\n      return areTypedArraysEqual(a, b, state);\n    }\n\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = getTag(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return (\n        typeof a.then !== 'function' &&\n        typeof b.then !== 'function' &&\n        areObjectsEqual(a, b, state)\n      );\n    }\n\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n\n/**\n * Create the configuration object used for building comparators.\n */\nexport function createEqualityComparatorConfig<Meta>({\n  circular,\n  createCustomConfig,\n  strict,\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\n  let config = {\n    areArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areArraysEqualDefault,\n    areDatesEqual: areDatesEqualDefault,\n    areMapsEqual: strict\n      ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault)\n      : areMapsEqualDefault,\n    areObjectsEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areObjectsEqualDefault,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\n    areRegExpsEqual: areRegExpsEqualDefault,\n    areSetsEqual: strict\n      ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault)\n      : areSetsEqualDefault,\n    areTypedArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areTypedArraysEqual,\n  };\n\n  if (createCustomConfig) {\n    config = assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n\n    config = assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual,\n    });\n  }\n\n  return config;\n}\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createInternalEqualityComparator<Meta>(\n  compare: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function (\n    a: any,\n    b: any,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    state: State<Meta>,\n  ) {\n    return compare(a, b, state);\n  };\n}\n\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nexport function createIsEqual<Meta>({\n  circular,\n  comparator,\n  createState,\n  equals,\n  strict,\n}: CreateIsEqualOptions<Meta>) {\n  if (createState) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      const { cache = circular ? new WeakMap() : undefined, meta } =\n        createState!();\n\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  if (circular) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined as Meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict,\n  } as State<Meta>;\n\n  return function isEqual<A, B>(a: A, b: B): boolean {\n    return comparator(a, b, state);\n  };\n}\n","import {\n  createEqualityComparatorConfig,\n  createEqualityComparator,\n  createInternalEqualityComparator,\n  createIsEqual,\n} from './comparator';\nimport type { CustomEqualCreatorOptions } from './internalTypes';\nimport { sameValueZeroEqual } from './utils';\n\nexport { sameValueZeroEqual };\nexport * from './internalTypes';\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport const deepEqual = createCustomEqual();\n\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nexport const strictDeepEqual = createCustomEqual({ strict: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport const circularDeepEqual = createCustomEqual({ circular: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport const shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nexport const strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport const circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true,\n});\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(\n  options: CustomEqualCreatorOptions<Meta> = {},\n) {\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false,\n  } = options;\n\n  const config = createEqualityComparatorConfig<Meta>(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator\n    ? createCustomInternalComparator(comparator)\n    : createInternalEqualityComparator(comparator);\n\n  return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n"]},"metadata":{},"sourceType":"module"}